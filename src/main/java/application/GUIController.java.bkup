package application;

import javafx.event.ActionEvent;
import javafx.fxml.FXML;
import javafx.fxml.FXMLLoader;
import javafx.scene.Node;
import javafx.scene.Parent;
import javafx.scene.Scene;
import javafx.scene.control.Button;
import javafx.scene.control.CheckBox;
import javafx.scene.control.Label;
import javafx.scene.control.TextField;
import javafx.scene.image.Image;
import javafx.scene.image.ImageView;
import javafx.scene.layout.TilePane;
import javafx.scene.layout.VBox;
import javafx.scene.text.Text;
import javafx.stage.Stage;
import java.io.IOException;
import java.time.Month;
import java.time.ZoneOffset;
import java.time.ZonedDateTime;
import java.util.Optional;


public class GUIController {
    private Stage stage;
    private Scene scene;

    @FXML private CheckBox filterNebula;
    @FXML private CheckBox filterGalaxy;
    @FXML private CheckBox filterOpenCluster;
    @FXML private CheckBox filterGlobularCluster;
    @FXML private CheckBox filterPlanetaryNebula;
    @FXML private CheckBox filterSupernovaRemnant;
    @FXML private CheckBox filterAsterism;
    @FXML private CheckBox filterOther;
    @FXML private CheckBox filterJan;
    @FXML private CheckBox filterFeb;
    @FXML private CheckBox filterMar;
    @FXML private CheckBox filterApr;
    @FXML private CheckBox filterMay;
    @FXML private CheckBox filterJune;
    @FXML private CheckBox filterJuly;
    @FXML private CheckBox filterAug;
    @FXML private CheckBox filterSept;
    @FXML private CheckBox filterNov;
    @FXML private CheckBox filterDec;
    @FXML private CheckBox filterOct;
    @FXML private CheckBox filterIsVis;
    @FXML private TextField searchBar;
    @FXML private TilePane gridPane;

    @FXML
    public void initialize() {

        if (filterNebula != null) {filterNebula.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterGalaxy != null){filterGalaxy.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterOpenCluster != null){filterOpenCluster.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterGlobularCluster != null){filterGlobularCluster.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterPlanetaryNebula != null){filterPlanetaryNebula.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterSupernovaRemnant != null){filterSupernovaRemnant.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterAsterism != null){filterAsterism.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterOther != null){filterOther.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterJan != null){filterJan.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterFeb != null){filterFeb.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterMar != null){filterMar.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterApr != null){filterApr.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterMay != null){filterMay.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterJune != null){filterJune.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterJuly != null){filterJuly.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterAug != null){filterAug.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterSept!= null){filterSept.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterOct != null){filterOct.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterNov != null){filterNov.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterDec != null){filterDec.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (filterIsVis != null){filterIsVis.selectedProperty().addListener((o, old, now) -> applyFilters());}
        if (searchBar != null){searchBar.textProperty().addListener((o, old, now) -> applyFilters());}
        clearFields();

        try {
            Object obj = Serializer.load("observatory.ser");
            if (obj instanceof Observatory) {
                observatory = (Observatory) obj;  // use the updated observatory instance
            } else {
                observatory = new Observatory();  // fallback if loading fails
                }
        } catch (Exception e) {
            e.printStackTrace();
            observatory = new Observatory();  // fallback if an exception occurs
        }
        attachObjectsToVBox();

    }

    private void attachObjectsToVBox() {

        try{
            Catalogue.loadCatalogue();
        }
        catch(Exception e){
            System.out.println("An error has occurred: "+e);
        }
        Catalogue c =Catalogue.getInstance();
        if(gridPane!=null){
            for(Node n: gridPane.getChildren()){
                if(!(n instanceof VBox cell)) continue;
                String name=null;

                for(Node child: cell.getChildren()){
                    if(child instanceof Button btn){
                        name=btn.getText();
                        break;
                    }
                }
                if(name == null) continue;
                CelestialObject obj = c.get(name);
                if(obj!=null){
                    cell.setUserData(obj);
                }

            }
        }
    }

    public void applyFilters() {
        String search= searchBar.getText().toLowerCase();

                for(Node n: gridPane.getChildren()){
                    if(!(n instanceof VBox cell)) continue;

                    CelestialObject obj = (CelestialObject) cell.getUserData();
                    if (obj == null) continue;



                    boolean matchSearch= ((search.isBlank())||obj.toString().toLowerCase().contains(search));


                    String type=obj.getObjectType().toString();
                    boolean matchType=(filterNebula.isSelected()&&(type.equals("Nebula"))
                            || (filterGlobularCluster.isSelected()&&type.equals("Globular Cluster"))||
                            (filterOpenCluster.isSelected()&&type.equals("Open Cluster"))||
                            (filterGalaxy.isSelected()&&type.equals("Galaxy"))||
                            (filterOther.isSelected()&&type.equals("Other"))||
                            (filterPlanetaryNebula.isSelected()&&type.equals("Planetary Nebula"))||
                            (filterSupernovaRemnant.isSelected()&&type.equals("Supernova Remnant"))||
                            (filterAsterism.isSelected()&&type.equals("Asterism"))||
                            (!filterOther.isSelected()&&!filterNebula.isSelected()&&!filterGlobularCluster.isSelected()
                                    &&!filterGalaxy.isSelected()&&!filterOpenCluster.isSelected()
                                    &&!filterSupernovaRemnant.isSelected()&&!filterAsterism.isSelected()
                                    &&!filterPlanetaryNebula.isSelected()));

                    double Lat= observatory.getLatitude();
                    double Long= observatory.getLongitude();
                    double Dec=obj.getDeclination();
                    double RA=obj.getRightAscension();
                    ZonedDateTime now = ZonedDateTime.now(ZoneOffset.UTC);

                    boolean matchVisibility=((filterIsVis.isSelected()&&obj.isVisible(observatory, now ,observatory.getTelescope()))
                            ||(filterJan.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.JANUARY))
                            ||(filterFeb.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.FEBRUARY))
                            ||(filterMar.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.MARCH))
                            ||(filterApr.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.APRIL))
                            ||(filterMay.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.MAY))
                            ||(filterJune.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.JUNE))
                            ||(filterJuly.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.JULY))
                            ||(filterAug.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.AUGUST))
                            ||(filterSept.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.SEPTEMBER))
                            ||(filterOct.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.OCTOBER))
                            ||(filterNov.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.NOVEMBER))
                            ||(filterDec.isSelected()&&SkyPosition.isVisibleDuringMonth(Lat,Long,RA,Dec, Month.DECEMBER))
                            ||(!filterJan.isSelected()&&!filterFeb.isSelected()&&!filterMar.isSelected()&&!filterApr.isSelected()&&!filterMay.isSelected()
                            &&!filterJune.isSelected()&&!filterJuly.isSelected()&&!filterAug.isSelected()&&!filterSept.isSelected()&&!filterOct.isSelected()
                            &&!filterNov.isSelected()&&!filterDec.isSelected()));

                    boolean show = matchSearch && matchType && matchVisibility;
                    cell.setVisible(show);
                    cell.setManaged(show);
                }

            }

    public void switchHome(ActionEvent event) throws IOException {
        Parent root = FXMLLoader.load(getClass().getResource("/fxml/home2.fxml"));
        stage=(Stage)((Node)event.getSource()).getScene().getWindow();
        scene= new Scene(root);
        stage.setScene(scene);
        stage.show();
    }
    public void switchObject(ActionEvent event) throws IOException {
        Button clicked=(Button)event.getSource();
        Parent cell=clicked.getParent();
        CelestialObject obj=(CelestialObject) cell.getUserData();



        FXMLLoader loader = new FXMLLoader(getClass().getResource("/fxml/Main.fxml"));
        Parent root = loader.load();

        GUIController controller = loader.getController();
        controller.displayCelestialObject(obj);

        stage=(Stage)((Node)event.getSource()).getScene().getWindow();
        scene= new Scene(root);
        stage.setScene(scene);
        stage.show();
    }
    @FXML
    private void switchObstruction(ActionEvent event) throws IOException {
        ObjGUI objGUI = new ObjGUI();
        Stage stage = objGUI.show();

        stage.setOnHidden(e -> refreshHomeGUI());
    }
    @FXML
    private void switchTelescope(ActionEvent event) throws IOException {
        TeleGUI teleGUI = new TeleGUI(this.observatory);
        Stage stage = teleGUI.show();

        stage.setOnHidden(e -> refreshHomeGUI());
    }
    private void refreshHomeGUI(){
        System.out.println("refreshed");
    }
    @FXML private Button backButton;
    @FXML private ImageView objectImage;
    @FXML private Label commonNameLabel;
   // @FXML private Label nextVisibleLabel;

    @FXML private Text messierNumberText;
    @FXML private Text objectTypeText;
    @FXML private Text distanceText;
    @FXML private Text constellationText;
    @FXML private Text magnitudeText;
    @FXML private Text dimensionsText;
    @FXML private Text rightAscensionText;
    @FXML private Text declinationText;
    @FXML private Text altitudeText;
    @FXML private Text azimuthText;
   

    private Observatory observatory;


    private void clearFields() {
       if(commonNameLabel!=null){commonNameLabel.setText("");}
       // if(nextVisibleLabel!=null){nextVisibleLabel.setText("");}
        if(messierNumberText!=null){messierNumberText.setText("");}
        if(objectTypeText!=null){objectTypeText.setText("");}
        if(distanceText!=null){distanceText.setText("");}
        if(constellationText!=null){constellationText.setText("");}
        if(magnitudeText!=null){magnitudeText.setText("");}
        if(dimensionsText!=null){dimensionsText.setText("");}
        if(rightAscensionText!=null){rightAscensionText.setText("");}
        if(declinationText!=null){declinationText.setText("");}
        if(altitudeText!=null){altitudeText.setText("");}
        if(azimuthText!=null){azimuthText.setText("");}
        if(objectImage!=null){objectImage.setImage(null);}
    }

    public void displayCelestialObject(CelestialObject obj) {
        if (obj == null) return;

        commonNameLabel.setText(obj.getCommonName());
        messierNumberText.setText(obj.getMessierIndex());
        objectTypeText.setText(obj.getObjectType().toString());
        distanceText.setText(obj.getDistance());
        constellationText.setText(obj.getConstellation());
        magnitudeText.setText(Double.toString(obj.getApparentMagnitude()));
        String dimensionsStr = obj.getApparentDimensionsString();
        dimensionsText.setText(dimensionsStr);


        rightAscensionText.setText(SkyPosition.doubleToHMS(obj.getRightAscension()));
        declinationText.setText(SkyPosition.doubleToDMS(obj.getDeclination()));

        // altitude + azimuth
        ZonedDateTime now = ZonedDateTime.now();
        double alt = SkyPosition.getAltitude(now, observatory.getLatitude(), observatory.getLongitude(),
                obj.getRightAscension(), obj.getDeclination());
        double az = SkyPosition.getAzimuth(now, observatory.getLatitude(), observatory.getLongitude(),
                obj.getRightAscension(), obj.getDeclination());

        altitudeText.setText(String.format("%.2f°", alt));
        azimuthText.setText(String.format("%.2f°", az));

        // monthly visibility periods
       // nextVisibleLabel.setText(computeMonthlyVisibilityPeriods(obj));

        // image
        if (obj.getImagePath() != null && !obj.getImagePath().isEmpty()) {
            try {
                Image img = new Image(getClass().getResourceAsStream(obj.getImagePath()));
                objectImage.setImage(img);
            } catch (Exception e) {
                System.err.println("Failed to load image: " + obj.getImagePath());
                objectImage.setImage(null);
            }
        } else {
            objectImage.setImage(null);
        }
    }

   /* private String computeMonthlyVisibilityPeriods(CelestialObject obj) {
        StringBuilder sb = new StringBuilder();
        Observatory observ = this.observatory;

        Optional<List<ZonedDateTime[]>> yearRanges =
                SkyPosition.getYearVisibilityRanges(
                        observ.getLatitude(),
                        observ.getLongitude(),
                        obj.getRightAscension(),
                        obj.getDeclination()
                );

        for (Month month : Month.values()) {
            sb.append(capitalize(month.name())).append(": ");

            if (yearRanges.isPresent()) {
                List<ZonedDateTime[]> ranges = yearRanges.get();
                List<String> monthPeriods = new ArrayList<>();

                int currentYear = ZonedDateTime.now().getYear();
                ZonedDateTime monthStart = ZonedDateTime.of(currentYear, month.getValue(), 1, 0, 0, 0, 0, ZoneOffset.UTC);
                ZonedDateTime monthEnd = monthStart.plusMonths(1).minusSeconds(1);

                for (ZonedDateTime[] range : ranges) {
                    ZonedDateTime rangeStart = range[0];
                    ZonedDateTime rangeEnd = range[1];

                    // Check if the range overlaps this month
                    if (!rangeEnd.isBefore(monthStart) && !rangeStart.isAfter(monthEnd)) {
                        ZonedDateTime visibleStart = rangeStart.isBefore(monthStart) ? monthStart : rangeStart;
                        ZonedDateTime visibleEnd = rangeEnd.isAfter(monthEnd) ? monthEnd : rangeEnd;

                        monthPeriods.add(String.format("%d %02d:%02d – %d %02d:%02d",
                                visibleStart.getDayOfMonth(), visibleStart.getHour(), visibleStart.getMinute(),
                                visibleEnd.getDayOfMonth(), visibleEnd.getHour(), visibleEnd.getMinute()));
                    }
                }

                if (monthPeriods.isEmpty()) {
                    sb.append("Not visible");
                } else {
                    sb.append(String.join(", ", monthPeriods));
                }
            } else {
                sb.append("Not visible");
            }

            sb.append("\n");
        }

        return sb.toString();
    }

    private String capitalize(String s) {
        String lower = s.toLowerCase();
        return Character.toUpperCase(lower.charAt(0)) + lower.substring(1);
    }*/
}



